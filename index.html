<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>SVG Path Editor with Fabric.js</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.9.359/pdf.min.js"></script>
    <style>
        :root {
            --bg-color: #fff;
            --grid-color-1: #366;
            --grid-color-2: #a9a9a9;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }

        .toolbar {
            padding: 10px;
            background: #f0f0f0;
            border-bottom: 1px solid #ccc;
        }

        .media-wrapper {
            width: 100vw;
            height: calc(100vh - 50px);
            position: relative;
            overflow: hidden;
            background-color: var(--bg-color);
            background-image:
                linear-gradient(var(--grid-color-1) 1.5px, transparent 1.5px),
                linear-gradient(90deg, var(--grid-color-1) 1.5px, transparent 1.5px),
                linear-gradient(var(--grid-color-2) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color-2) 1px, transparent 1px);
            background-size: 100px 100px, 100px 100px, 20px 20px, 20px 20px;
            background-position: -1.5px -1.5px, -1.5px -1.5px, -1px -1px, -1px -1px;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        #property-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            display: none;
        }
    </style>
</head>

<body>
    <div class="toolbar">
        <button id="load-pdf">Load PDF</button>
        <button id="load-svg">Load SVG</button>
        <button id="mode-pan">Pan</button>
        <button id="mode-select">Select</button>
        <!-- <button id="mode-draw">Draw</button> -->
        <button id="mode-draw-line">Draw Line</button>
        <button id="mode-draw-circle">Draw Circle</button>
        <button id="mode-draw-rectangle">Draw Rectangle</button>
        <button id="zoom-fit">Zoom to Fit</button>
        <span>Zoom: <span id="zoom-level">100%</span></span>
    </div>
    <div class="media-wrapper">
        <div id="canvas-container">
            <canvas id="fabric-canvas"></canvas>
        </div>
    </div>
    <div id="property-panel">
        <h3>Object Properties</h3>
        <label>
            Stroke Width:
            <input type="number" id="stroke-width" min="1" max="10" step="1" value="1">
        </label>
        <button id="delete-object">Delete Object</button>
    </div>

    <input type="file" id="pdf-input" accept=".pdf" style="display: none;">
    <input type="file" id="svg-input" accept=".svg" style="display: none;">

    <script>
        // PDF.js initialization
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.9.359/pdf.worker.min.js';

        // Initialize Fabric canvas
        const canvas = new fabric.Canvas('fabric-canvas', {
            width: window.innerWidth,
            height: window.innerHeight - 50,
            backgroundColor: 'rgba(0,0,0,0)'
        });

        // Global variables
        let currentPdf = null;
        let currentMode = 'select';
        let isDrawing = false;
        let startPoint;
        let tempShape;

        // Initialize
        function init() {
            document.getElementById('load-pdf').addEventListener('click', () => document.getElementById('pdf-input').click());
            document.getElementById('load-svg').addEventListener('click', () => document.getElementById('svg-input').click());
            document.getElementById('mode-pan').addEventListener('click', () => setMode('pan'));
            document.getElementById('mode-select').addEventListener('click', () => setMode('select'));
            // document.getElementById('mode-draw').addEventListener('click', () => setMode('draw'));
            document.getElementById('zoom-fit').addEventListener('click', zoomToFit);
            document.getElementById('pdf-input').addEventListener('change', loadPDF);
            document.getElementById('svg-input').addEventListener('change', loadSVG);
            document.getElementById('stroke-width').addEventListener('change', updateStrokeWidth);
            document.getElementById('delete-object').addEventListener('click', deleteSelectedObject);
            document.getElementById('mode-draw-line').addEventListener('click', () => setMode('draw-line'));
            document.getElementById('mode-draw-circle').addEventListener('click', () => setMode('draw-circle'));
            document.getElementById('mode-draw-rectangle').addEventListener('click', () => setMode('draw-rectangle'));

            canvas.on('mouse:down', handleMouseDown);
            canvas.on('mouse:move', handleMouseMove);
            canvas.on('mouse:up', handleMouseUp);
            canvas.on('object:moving', onObjectMoving);

            // Set global object properties
            fabric.Object.prototype.transparentCorners = false;
            fabric.Object.prototype.cornerColor = 'blue';
            fabric.Object.prototype.cornerStyle = 'circle';
            fabric.Object.prototype.cornerSize = 10;
            fabric.Object.prototype.padding = 5;

            // Ensure newly added objects are standardized
            canvas.on('object:added', function (e) {
                standardizeObject(e.target);
            });

            // Improve selection behavior
            canvas.on('selection:created', function (e) {
                if (e.selected.length > 1) {
                    e.target.set({
                        hasControls: true,
                        hasBorders: true
                    });
                }
            });

            window.addEventListener('resize', resizeCanvas);

            canvas.on('selection:created', showPropertyPanel);
            canvas.on('selection:cleared', hidePropertyPanel);
            canvas.on('mouse:down', function (options) {
                if (editMode && options.target && options.target.type === 'path') {
                    canvas.setActiveObject(options.target);
                }
            });

            document.addEventListener('keydown', function (e) {
                if (e.key === 'Escape' && editMode) {
                    const activePath = canvas.getActiveObject();
                    if (activePath && activePath.type === 'path') {
                        makePathEditable(activePath);
                        showPropertyPanel({ selected: [activePath] });
                    }
                }
            });

            canvas.on('object:modified', function (e) {
                if (e.target.type === 'path' && e.target.edit) {
                    updatePathPoints(e.target);
                }
            });
        }

        // Load PDF
        async function loadPDF(event) {
            const file = event.target.files[0];
            if (file) {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                currentPdf = pdf;
                renderPage(1);
            }
        }

        // Render PDF page
        async function renderPage(pageNumber) {
            const page = await currentPdf.getPage(pageNumber);
            const viewport = page.getViewport({ scale: 1 });
            const pdfCanvas = document.createElement('canvas');
            const context = pdfCanvas.getContext('2d');
            pdfCanvas.height = viewport.height;
            pdfCanvas.width = viewport.width;

            await page.render({ canvasContext: context, viewport: viewport }).promise;

            fabric.Image.fromURL(pdfCanvas.toDataURL(), function (img) {
                canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
                    scaleX: canvas.width / img.width,
                    scaleY: canvas.height / img.height
                });
                zoomToFit();
            });
        }

        function standardizeObject(obj) {
            obj.set({
                selectable: true,
                hasControls: true,
                hasBorders: true,
                perPixelTargetFind: true,
                targetFindTolerance: 4,
                strokeUniform: true,
                objectCaching: false
            });

            if (obj.type === 'path' && !obj.customControlPoints) {
                addCurvePoints(obj);
            }
            
            if (obj.type === 'path') {
                obj.strokeLineJoin = 'round';
                obj.strokeLineCap = 'round';

                // Check if the path is a straight line and add arc control if it is
                if (obj.path.length === 2 && obj.path[0][0] === 'M' && obj.path[1][0] === 'L') {
                    addArcControlToLine(obj);
                }
            }

            if (obj.type === 'line') {
                // Convert line to path and add arc control
                const path = new fabric.Path(`M ${obj.x1} ${obj.y1} L ${obj.x2} ${obj.y2}`, {
                    stroke: obj.stroke,
                    strokeWidth: obj.strokeWidth,
                    selectable: true,
                    evented: true,
                    objectCaching: false
                });
                canvas.remove(obj);
                canvas.add(path);
                addArcControlToLine(path);
                return path;
            }

            if (obj.type === 'group') {
                obj.getObjects().forEach(standardizeObject);
            }

            return obj;
        }

        // Load SVG
        function loadSVG(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    fabric.loadSVGFromString(e.target.result, function (objects, options) {
                        canvas.clear();

                        objects.forEach(obj => {
                            canvas.add(standardizeObject(obj));
                        });

                        canvas.renderAll();
                        refreshCanvas();
                        // zoomToFit();
                    });
                };
                reader.readAsText(file);
            }
        }

        // Set interaction mode
        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.toolbar button').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`mode-${mode}`).classList.add('active');

            canvas.isDrawingMode = false;
            canvas.selection = mode === 'select';

            canvas.forEachObject(function (object) {
                object.selectable = mode === 'select';
                object.evented = mode === 'select';
            });

            if (mode === 'pan') {
                canvas.discardActiveObject();
            }

            canvas.renderAll();
        }

        function handleMouseDown(o) {
            if (!currentMode.startsWith('draw-')) return;

            isDrawing = true;
            startPoint = canvas.getPointer(o.e);

            switch (currentMode) {
                case 'draw-line':
                    tempShape = new fabric.Line([startPoint.x, startPoint.y, startPoint.x, startPoint.y], {
                        stroke: 'black',
                        strokeWidth: 2,
                        selectable: false,
                        evented: false
                    });
                    break;
                case 'draw-circle':
                    tempShape = new fabric.Circle({
                        left: startPoint.x,
                        top: startPoint.y,
                        radius: 0,
                        stroke: 'black',
                        strokeWidth: 2,
                        fill: 'transparent',
                        selectable: false,
                        evented: false
                    });
                    break;
                case 'draw-rectangle':
                    tempShape = new fabric.Rect({
                        left: startPoint.x,
                        top: startPoint.y,
                        width: 0,
                        height: 0,
                        stroke: 'black',
                        strokeWidth: 2,
                        fill: 'transparent',
                        selectable: false,
                        evented: false
                    });
                    break;
            }

            canvas.add(tempShape);
            canvas.renderAll();
        }

        function handleMouseMove(o) {
            if (!isDrawing) return;

            const pointer = canvas.getPointer(o.e);

            switch (currentMode) {
                case 'draw-line':
                    tempShape.set({ x2: pointer.x, y2: pointer.y });
                    break;
                case 'draw-circle':
                    const radius = Math.sqrt(Math.pow(pointer.x - startPoint.x, 2) + Math.pow(pointer.y - startPoint.y, 2)) / 2;
                    tempShape.set({
                        left: Math.min(startPoint.x, pointer.x),
                        top: Math.min(startPoint.y, pointer.y),
                        radius: radius
                    });
                    break;
                case 'draw-rectangle':
                    const width = Math.abs(pointer.x - startPoint.x);
                    const height = Math.abs(pointer.y - startPoint.y);
                    tempShape.set({
                        left: Math.min(startPoint.x, pointer.x),
                        top: Math.min(startPoint.y, pointer.y),
                        width: width,
                        height: height
                    });
                    break;
            }

            canvas.renderAll();
        }



        function addArcControlToLine(line) {
            line.controls = fabric.Object.prototype.controls;
            line.controls.arcControl = new fabric.Control({
                x: 0,
                y: -0.5,
                offsetY: -20,
                cursorStyle: 'pointer',
                mouseUpHandler: arcControlMouseUp,
                render: function (ctx, left, top, styleOverride, fabricObject) {
                    ctx.save();
                    ctx.translate(left, top);
                    ctx.fillStyle = 'blue';
                    ctx.beginPath();
                    ctx.arc(0, 0, 6, 0, 2 * Math.PI, false);
                    ctx.fill();
                    ctx.restore();
                },
                actionHandler: arcControlAction
            });

            line.setCoords();
            canvas.requestRenderAll();
        }

        function arcControlAction(eventData, transform, x, y) {
            const line = transform.target;
            const lineLength = Math.sqrt(Math.pow(line.path[1][1] - line.path[0][1], 2) + Math.pow(line.path[1][2] - line.path[0][2], 2));
            const offset = y / lineLength;
            updateLineArc(line, offset);
            return true;
        }

        function arcControlMouseUp(eventData, transform) {
            const line = transform.target;
            canvas.setActiveObject(line);
            canvas.requestRenderAll();
        }

        function updateLineArc(line, offset) {
            const startPoint = line.path[0].slice(1);
            const endPoint = line.path[1].slice(1);

            const midPoint = {
                x: (startPoint[0] + endPoint[0]) / 2,
                y: (startPoint[1] + endPoint[1]) / 2
            };
            const length = Math.sqrt(Math.pow(endPoint[0] - startPoint[0], 2) + Math.pow(endPoint[1] - startPoint[1], 2));

            offset = Math.max(Math.min(offset, 0.5), -0.5);

            const controlPoint = {
                x: midPoint.x,
                y: midPoint.y - offset * length
            };

            const newPath = `M ${startPoint[0]} ${startPoint[1]} Q ${controlPoint.x} ${controlPoint.y} ${endPoint[0]} ${endPoint[1]}`;
            line.set({ path: newPath });

            line.setCoords();
            canvas.requestRenderAll();
        }

        function handleMouseUp() {
            if (!isDrawing) return;

            isDrawing = false;

            if (currentMode === 'draw-line') {
                const startPoint = { x: tempShape.x1, y: tempShape.y1 };
                const endPoint = { x: tempShape.x2, y: tempShape.y2 };
                const midPoint = {
                    x: (startPoint.x + endPoint.x) / 2,
                    y: (startPoint.y + endPoint.y) / 2
                };

                const path = new fabric.Path(`M ${startPoint.x} ${startPoint.y} Q ${midPoint.x}, ${midPoint.y}, ${endPoint.x}, ${endPoint.y}`, {
                    fill: '',
                    stroke: 'black',
                    objectCaching: false
                });

                canvas.remove(tempShape);
                canvas.add(path);

                addCurvePoints(path);

                canvas.setActiveObject(path);
            }

            canvas.requestRenderAll();
            tempShape = null;
        }

        function addCurvePoints(path) {
            const points = path.path;

            const p0 = makeCurveCircle(points[0][1], points[0][2], null, path, null);
            p0.name = "p0";
            canvas.add(p0);

            const p1 = makeCurvePoint(points[1][1], points[1][2], null, path, null);
            p1.name = "p1";
            canvas.add(p1);

            const p2 = makeCurveCircle(points[1][3], points[1][4], null, path, null);
            p2.name = "p2";
            canvas.add(p2);

            path.customControlPoints = [p0, p1, p2];
        }

        function makeCurveCircle(left, top, line1, line2, line3) {
            var c = new fabric.Circle({
                left: left,
                top: top,
                strokeWidth: 5,
                radius: 12,
                fill: '#fff',
                stroke: '#666'
            });
            c.hasBorders = c.hasControls = false;
            c.line1 = line1;
            c.line2 = line2;
            c.line3 = line3;
            return c;
        }

        function makeCurvePoint(left, top, line1, line2, line3) {
            var c = new fabric.Circle({
                left: left,
                top: top,
                strokeWidth: 8,
                radius: 14,
                fill: '#fff',
                stroke: '#666'
            });
            c.hasBorders = c.hasControls = false;
            c.line1 = line1;
            c.line2 = line2;
            c.line3 = line3;
            return c;
        }

        function onObjectMoving(e) {
            var p = e.target;
            if (p.name == "p0" || p.name == "p2") {
                var path = p.line2;
                if (p.name == "p0") {
                    path.path[0][1] = p.left;
                    path.path[0][2] = p.top;
                } else if (p.name == "p2") {
                    path.path[1][3] = p.left;
                    path.path[1][4] = p.top;
                }
            } else if (p.name == "p1") {
                var path = p.line2;
                path.path[1][1] = p.left;
                path.path[1][2] = p.top;
            }
            canvas.requestRenderAll();
        }

        function refreshCanvas() {
            canvas.forEachObject(function (obj) {
                standardizeObject(obj);
            });
            canvas.renderAll();
        }

        // Zoom to fit
        function zoomToFit() {
            canvas.setZoom(1);
            canvas.setDimensions({
                width: window.innerWidth,
                height: window.innerHeight - 50
            });
            canvas.calcOffset();

            const objects = canvas.getObjects();
            if (objects.length > 0) {
                const group = new fabric.Group(objects, { active: false });
                canvas.setViewportTransform([1, 0, 0, 1, 0, 0]); // Reset zoom and pan
                const canvasWidth = canvas.getWidth();
                const canvasHeight = canvas.getHeight();
                const groupWidth = group.width;
                const groupHeight = group.height;
                const scaleX = canvasWidth / groupWidth;
                const scaleY = canvasHeight / groupHeight;
                const scale = Math.min(scaleX, scaleY) * 0.9; // 90% to leave some margin

                canvas.setZoom(scale);
                canvas.setViewportTransform([
                    scale, 0, 0, scale,
                    (canvasWidth - groupWidth * scale) / 2,
                    (canvasHeight - groupHeight * scale) / 2
                ]);
                canvas.remove(group); // Remove the temporary group
            } else if (canvas.backgroundImage) {
                // Existing code for background image...
            }

            updateZoomLevel();
        }

        // Update zoom level display
        function updateZoomLevel() {
            document.getElementById('zoom-level').textContent = `${Math.round(canvas.getZoom() * 100)}%`;
        }

        // Resize canvas
        function resizeCanvas() {
            canvas.setDimensions({
                width: window.innerWidth,
                height: window.innerHeight - 50
            });
            canvas.calcOffset();
            canvas.renderAll();
        }

        // Show property panel
        function showPropertyPanel(options) {
            const panel = document.getElementById('property-panel');
            panel.style.display = 'block';
            const obj = options.selected[0];

            // Clear existing controls
            while (panel.firstChild) {
                panel.removeChild(panel.firstChild);
            }

            // Add title
            const title = document.createElement('h3');
            title.textContent = 'Object Properties';
            panel.appendChild(title);

            // Add stroke width control
            const strokeWidthLabel = document.createElement('label');
            strokeWidthLabel.textContent = 'Stroke Width: ';
            const strokeWidthInput = document.createElement('input');
            strokeWidthInput.type = 'number';
            strokeWidthInput.min = '1';
            strokeWidthInput.max = '10';
            strokeWidthInput.step = '1';
            strokeWidthInput.value = obj.strokeWidth || 1;
            strokeWidthInput.addEventListener('change', updateStrokeWidth);
            strokeWidthLabel.appendChild(strokeWidthInput);
            panel.appendChild(strokeWidthLabel);

            // Add delete button
            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Delete Object';
            deleteButton.addEventListener('click', deleteSelectedObject);
            panel.appendChild(deleteButton);

            // Add edit points button for paths
            if (obj.type === 'path') {
                const editButton = document.createElement('button');
                editButton.textContent = editMode ? 'Exit Edit Mode' : 'Edit Points';
                editButton.addEventListener('click', () => {
                    makePathEditable(obj);
                    editButton.textContent = editMode ? 'Exit Edit Mode' : 'Edit Points';
                });
                panel.appendChild(editButton);
            }
        }

        // Hide property panel
        function hidePropertyPanel() {
            document.getElementById('property-panel').style.display = 'none';
        }

        function updatePathPoints(path) {
            if (!path.edit) {
                path.controls = fabric.Object.prototype.controls;
                return;
            }

            const points = path.path;
            path.controls = {};
            points.forEach((point, index) => {
                if (point[0] === 'M' || point[0] === 'L') {
                    path.controls[`p${index}`] = new fabric.Control({
                        positionHandler: function (dim, finalMatrix, fabricObject) {
                            return new fabric.Point(point[1], point[2])
                                .transform(fabricObject.calcTransformMatrix());
                        },
                        actionHandler: function (eventData, transform, x, y) {
                            const invertedMatrix = fabric.util.invertTransform(path.calcTransformMatrix());
                            const newPoint = fabric.util.transformPoint(new fabric.Point(x, y), invertedMatrix);
                            point[1] = newPoint.x;
                            point[2] = newPoint.y;
                            return true;
                        },
                        actionName: 'modifyPolygon',
                        render: function (ctx, left, top, styleOverride, fabricObject) {
                            const size = this.sizeX;
                            ctx.fillStyle = editMode ? 'red' : 'blue';
                            ctx.beginPath();
                            ctx.arc(left, top, size, 0, 2 * Math.PI, false);
                            ctx.fill();
                        }
                    });
                }
            });
        }

        let editMode = false;

        function makePathEditable(path) {
            return
            if (path.type !== 'path') return;

            editMode = !editMode;
            path.edit = editMode;

            if (editMode) {
                // Enter edit mode
                canvas.discardActiveObject();
                canvas.selection = false;
                canvas.forEachObject(function (obj) {
                    obj.selectable = false;
                    obj.evented = false;
                });
                path.selectable = true;
                path.evented = true;
                canvas.setActiveObject(path);
            } else {
                // Exit edit mode
                canvas.selection = true;
                canvas.forEachObject(function (obj) {
                    obj.selectable = true;
                    obj.evented = true;
                });
            }

            updatePathPoints(path);
            canvas.requestRenderAll();
        }

        // Add this to your init function:
        canvas.on('mouse:dblclick', function (options) {
            if (options.target && options.target.type === 'path') {
                makePathEditable(options.target);
            }
        });

        // Update stroke width
        function updateStrokeWidth(e) {
            const obj = canvas.getActiveObject();
            if (obj) {
                obj.set('strokeWidth', parseInt(e.target.value));
                canvas.renderAll();
            }
        }

        // Delete selected object
        function deleteSelectedObject() {
            const obj = canvas.getActiveObject();
            if (obj) {
                canvas.remove(obj);
                hidePropertyPanel();
            }
        }

        // Initialize the application
        init();
    </script>
</body>

</html>